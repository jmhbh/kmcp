# {{.ProjectName}}

{{.ProjectName}} is a Model Context Protocol (MCP) server built with FastMCP featuring dynamic tool loading and HTTP transport support.

## Features

- **Dynamic Tool Loading**: Tools are automatically discovered and loaded from `src/tools/`
- **One Tool Per File**: Each tool is a single file with a function matching the filename
- **FastMCP Integration**: Leverages FastMCP for robust MCP protocol handling
- **MCP Protocol over HTTP**: Full MCP protocol support over HTTP
- **Configuration Management**: Tool-specific configuration via `kmcp.yaml`
- **Fail-Fast**: Server won't start if any tool fails to load
- **Auto-Generated Tests**: Automatic test generation for tool validation

## Project Structure

```
src/
├── tools/              # Tool implementations (one file per tool)
│   ├── echo.py         # Example echo tool
│   └── __init__.py     # Auto-generated tool registry
├── core/               # Dynamic loading framework
│   ├── server.py       # Dynamic MCP server
│   └── utils.py        # Shared utilities
└── main.py             # Entry point
kmcp.yaml               # Configuration file
tests/                  # Generated tests
```

## Quick Start

### Option 1: Local Development (with Python/uv)

1. **Install Dependencies**:
   ```bash
   uv sync
   ```

2. **Run the Server**:
   ```bash
   # Stdio mode (default MCP transport)
   uv run python src/main.py
   
   # HTTP mode with WebSocket MCP endpoint
   uv run python src/main.py --http
   
   # HTTP mode with custom host/port
   uv run python src/main.py --http --host 0.0.0.0 --port 8080
   ```

3. **Using uv Scripts**:
   ```bash
   # Development mode (HTTP on port 3000)
   uv run dev
   
   # HTTP mode
   uv run dev-http
   
   # Stdio mode
   uv run start
   ```

4. **Add New Tools**:
   ```bash
   # Create a new tool (no tool types needed!)
   kmcp add-tool weather
   
   # The tool file will be created at src/tools/weather.py
   # Edit it to implement your tool logic
   ```

### Option 2: Docker-Only Development (no local Python/uv required)

1. **Build Docker Image**:
   ```bash
   kmcp build --verbose
   ```

2. **Run in Container**:
   ```bash
   docker run -i {{.ProjectName}}:latest
   ```

3. **Deploy to Kubernetes**:
   ```bash
   kmcp deploy mcp --apply
   ```

4. **Add New Tools**:
   ```bash
   # Create a new tool
   kmcp add-tool weather
   
   # Edit the tool file, then rebuild
   kmcp build
   ```

## HTTP Transport Mode

The server supports running in HTTP mode for development and integration purposes.

### Starting in HTTP Mode

```bash
# Command line flag
python src/main.py --http

# Environment variable
MCP_HTTP_MODE=true python src/main.py

# Custom host and port
python src/main.py --http --host localhost --port 8080
```

### HTTP Endpoints

When running in HTTP mode, the server provides:

- **Root Info**: `GET /` - Server information and available endpoints
- **Health Check**: `GET /health` - Returns "OK" for monitoring
- **MCP Protocol**: `POST /mcp` - Full MCP protocol over HTTP
- **MCP Streaming**: `GET /mcp` - Server-Sent Events for long-running operations

### MCP Protocol Support

The server implements the full MCP protocol over HTTP, making it compatible with:

- **Transport Adapter**: Kubernetes deployment with transport adapter
- **MCP Inspector**: Standard MCP client tools
- **MCP SDKs**: Any MCP-compliant client

#### MCP Methods Supported

- **`tools/list`** - List all available tools
- **`tools/call`** - Execute a specific tool with arguments

#### Example MCP Protocol Requests

```bash
# List tools (MCP protocol)
curl -X POST http://localhost:8080/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "tools/list",
    "params": {}
  }'

# Call tool (MCP protocol)
curl -X POST http://localhost:8080/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 2,
    "method": "tools/call",
    "params": {
      "name": "echo",
      "arguments": {"message": "Hello World"}
    }
  }'
```

#### Backward Compatibility

For simple testing, the server also supports the legacy operation-based format:

```bash
# Legacy format (still supported)
curl -X POST http://localhost:8080/mcp \
  -H "Content-Type: application/json" \
  -d '{"operation": "list_tools"}'
```

### Environment Variables

- `MCP_HTTP_MODE`: Set to "true" to enable HTTP mode
- `HOST`: Host to bind to (default: localhost)
- `PORT`: Port to bind to (default: 3000)

### Development Scripts

```bash
# Quick HTTP development
uv run dev

# HTTP mode on specific port
uv run dev-http

# Stdio mode
uv run start

# HTTP mode
uv run start-http
```

### Testing HTTP Transport

Use the included example HTTP client to test your server:

```bash
# Start the server in HTTP mode
python src/main.py --http

# In another terminal, test the HTTP transport
python example_http_client.py
```

The example client tests both the health endpoint and MCP WebSocket connection.

## Creating Tools

### Basic Tool Structure

Each tool is a Python file in `src/tools/` containing a function decorated with `@mcp.tool()`:

```python
# src/tools/weather.py
from core.server import mcp
from core.utils import get_tool_config, get_env_var

@mcp.tool()
def weather(location: str) -> str:
    """Get weather information for a location."""
    
    # Get tool configuration
    config = get_tool_config("weather")
    api_key = get_env_var(config.get("api_key_env", "WEATHER_API_KEY"))
    base_url = config.get("base_url", "https://api.openweathermap.org/data/2.5")
    
    # TODO: Implement weather API call
    return f"Weather for {location}: Sunny, 72°F"
```

### Tool Examples

The generated tool template includes commented examples for common patterns:

```python
# HTTP API calls
# async with httpx.AsyncClient() as client:
#     response = await client.get(f"{base_url}/weather?q={location}&appid={api_key}")
#     return response.json()

# Database operations  
# async with asyncpg.connect(connection_string) as conn:
#     result = await conn.fetchrow("SELECT * FROM weather WHERE location = $1", location)
#     return dict(result)

# File processing
# with open(file_path, 'r') as f:
#     content = f.read()
#     return {"content": content, "size": len(content)}
```

## Configuration

Configure tools in `kmcp.yaml`:

```yaml
tools:
  weather:
    api_key_env: "WEATHER_API_KEY"
    base_url: "https://api.openweathermap.org/data/2.5"
    timeout: 30
  
  database:
    connection_string_env: "DATABASE_URL"
    max_connections: 10
```

## Testing

Run the generated tests to verify your tools load correctly:

```bash
uv run pytest tests/
```

## Development

### Adding Dependencies

Update `pyproject.toml` and run:

```bash
uv sync
```

### Code Quality

```bash
uv run black .
uv run ruff check .
uv run mypy .
```

## Deployment

### Docker

```bash
# Build image (handles lockfile automatically)
kmcp build

# Run container
docker run -i {{.ProjectName}}:latest
```

### Kubernetes

```bash
# Deploy to Kubernetes
kmcp deploy mcp --apply

# Check deployment status
kubectl get mcpserver {{.ProjectName}}
```